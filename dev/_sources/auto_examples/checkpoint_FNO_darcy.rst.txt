
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/checkpoint_FNO_darcy.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_checkpoint_FNO_darcy.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_checkpoint_FNO_darcy.py:


Training a TFNO on Darcy-Flow
=============================

In this example, we demonstrate how to use the small Darcy-Flow example we ship with the package
to train a Tensorized Fourier-Neural Operator

.. GENERATED FROM PYTHON SOURCE LINES 11-24

.. code-block:: default

    import torch
    import matplotlib.pyplot as plt
    import sys
    from neuralop.models import TFNO
    from neuralop import Trainer
    from neuralop.training import OutputEncoderCallback, CheckpointCallback
    from neuralop.datasets import load_darcy_flow_small
    from neuralop.utils import count_model_params
    from neuralop import LpLoss, H1Loss

    device = 'cpu'



.. GENERATED FROM PYTHON SOURCE LINES 25-26

Loading the Navier-Stokes dataset in 128x128 resolution

.. GENERATED FROM PYTHON SOURCE LINES 26-33

.. code-block:: default

    train_loader, test_loaders, output_encoder = load_darcy_flow_small(
            n_train=1000, batch_size=32, 
            test_resolutions=[16, 32], n_tests=[100, 50],
            test_batch_sizes=[32, 32],
    )



.. GENERATED FROM PYTHON SOURCE LINES 34-35

We create a tensorized FNO model

.. GENERATED FROM PYTHON SOURCE LINES 35-44

.. code-block:: default


    model = TFNO(n_modes=(16, 16), hidden_channels=32, projection_channels=64, factorization='tucker', rank=0.42)
    model = model.to(device)

    n_params = count_model_params(model)
    print(f'\nOur model has {n_params} parameters.')
    sys.stdout.flush()



.. GENERATED FROM PYTHON SOURCE LINES 45-46

Create the optimizer

.. GENERATED FROM PYTHON SOURCE LINES 46-52

.. code-block:: default

    optimizer = torch.optim.Adam(model.parameters(), 
                                    lr=8e-3, 
                                    weight_decay=1e-4)
    scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=30)



.. GENERATED FROM PYTHON SOURCE LINES 53-54

Creating the losses

.. GENERATED FROM PYTHON SOURCE LINES 54-61

.. code-block:: default

    l2loss = LpLoss(d=2, p=2)
    h1loss = H1Loss(d=2)

    train_loss = h1loss
    eval_losses={'h1': h1loss, 'l2': l2loss}



.. GENERATED FROM PYTHON SOURCE LINES 62-73

.. code-block:: default



    print('\n### MODEL ###\n', model)
    print('\n### OPTIMIZER ###\n', optimizer)
    print('\n### SCHEDULER ###\n', scheduler)
    print('\n### LOSSES ###')
    print(f'\n * Train: {train_loss}')
    print(f'\n * Test: {eval_losses}')
    sys.stdout.flush()



.. GENERATED FROM PYTHON SOURCE LINES 74-75

Create the trainer

.. GENERATED FROM PYTHON SOURCE LINES 75-90

.. code-block:: default

    trainer = Trainer(model=model, n_epochs=20,
                      device=device,
                      callbacks=[
                        OutputEncoderCallback(output_encoder),
                        CheckpointCallback(save_dir='./checkpoints',
                                           save_interval=10,
                                                save_optimizer=True,
                                                save_scheduler=True)
                            ],             
                      wandb_log=False,
                      log_test_interval=3,
                      use_distributed=False,
                      verbose=True)



.. GENERATED FROM PYTHON SOURCE LINES 91-92

Actually train the model on our small Darcy-Flow dataset

.. GENERATED FROM PYTHON SOURCE LINES 92-121

.. code-block:: default


    trainer.train(train_loader=train_loader,
                  test_loaders={},
                  optimizer=optimizer,
                  scheduler=scheduler, 
                  regularizer=False, 
                  training_loss=train_loss)


    # resume training from saved checkpoint at epoch 10

    trainer = Trainer(model=model, n_epochs=20,
                      device=device,
                      callbacks=[
                        OutputEncoderCallback(output_encoder),
                        CheckpointCallback(save_dir='./new_checkpoints',
                                                resume_from_dir='./checkpoints/ep_10')
                            ],             
                      wandb_log=False,
                      log_test_interval=3,
                      use_distributed=False,
                      verbose=True)

    trainer.train(train_loader=train_loader,
                  test_loaders={},
                  optimizer=optimizer,
                  scheduler=scheduler, 
                  regularizer=False, 
                  training_loss=train_loss)

.. GENERATED FROM PYTHON SOURCE LINES 122-132

Plot the prediction, and compare with the ground-truth 
Note that we trained on a very small resolution for
a very small number of epochs
In practice, we would train at larger resolution, on many more samples.

However, for practicity, we created a minimal example that
i) fits in just a few Mb of memory
ii) can be trained quickly on CPU

In practice we would train a Neural Operator on one or multiple GPUs

.. GENERATED FROM PYTHON SOURCE LINES 132-169

.. code-block:: default


    test_samples = test_loaders[32].dataset

    fig = plt.figure(figsize=(7, 7))
    for index in range(3):
        data = test_samples[index]
        # Input x
        x = data['x']
        # Ground-truth
        y = data['y']
        # Model prediction
        out = model(x.unsqueeze(0))

        ax = fig.add_subplot(3, 3, index*3 + 1)
        ax.imshow(x[0], cmap='gray')
        if index == 0: 
            ax.set_title('Input x')
        plt.xticks([], [])
        plt.yticks([], [])

        ax = fig.add_subplot(3, 3, index*3 + 2)
        ax.imshow(y.squeeze())
        if index == 0: 
            ax.set_title('Ground-truth y')
        plt.xticks([], [])
        plt.yticks([], [])

        ax = fig.add_subplot(3, 3, index*3 + 3)
        ax.imshow(out.squeeze().detach().numpy())
        if index == 0: 
            ax.set_title('Model prediction')
        plt.xticks([], [])
        plt.yticks([], [])

    fig.suptitle('Inputs, ground-truth output and prediction.', y=0.98)
    plt.tight_layout()
    fig.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.000 seconds)


.. _sphx_glr_download_auto_examples_checkpoint_FNO_darcy.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: checkpoint_FNO_darcy.py <checkpoint_FNO_darcy.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: checkpoint_FNO_darcy.ipynb <checkpoint_FNO_darcy.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
